<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //   function f(a,b,c) {
      //     console.log(a);
      //     console.log(b);
      //     console.log(c);
      //   }
      //   var args = [1,2,3]
      //   f.apply(this,args)
      //   扩展运算符 ...三点运算符
      //   1.拆包
      //   console.log(...args);
      //   f(...args);

      //   //2.后面还可以放表达式
      //   let a = 1;
      //   const arr = [
      //     ...(a>0?['a']:[])
      //   ]
      //   console.log(arr);
      //   console.log([...[],1]);

      //   3.思考连接两个数组的方法
      //   let arr1 = [1,2,3];
      //   let arr2 = [4,5,6];
      //   console.log(arr1.concat(arr2));
      //   console.log(arr1);

      //   4.想让原来的数组改变
      //   es5的解决办法
      //   Array.prototype.push.apply(arr1,arr2);
      //   console.log(arr1);
      //   es6的解决办法
      //   arr1.push(...arr2)
      //   console.log(arr1);

      //   5.扩展运算符只有函数调用的时候才可以放在圆括号中
      //   console.log((...[1,2]));

      //   6.赋值数组，浅拷贝
      //   const a1 = [1,2]
      //   const a2 = a1;// 复制
      //   console.log(a1 === a2); //指向同一个对象
      //   a2[0] = 2
      //   console.log(a1); //这不是浅拷贝是复制

      //   const a3 = a1.concat();//浅拷贝
      //   console.log(a3);
      //   console.log(a1 === a3); //没有指向同一个对象
      //  扩展运算符是浅拷贝，不是深拷贝
      //  const a4 = [...a1]
      //  console.log(a4);
      //  console.log(a4 === a1); //浅拷贝
      //  如果arr[0].a=4说明是浅拷贝，不等于说明是深拷贝
      //  let arr = [{a:1},2,3]
      //  let arr1 = [...arr]
      //  arr1[0].a = 4
      //  console.log(arr);
       
      //  深拷贝，除了递归还能用JSON.parse(JSON.stringfy())来实现
      //  如果此时的arr[0].a = 9说明是浅拷贝，不对等于说明是深拷贝
      //  let arr2 = JSON.parse(JSON.stringify(arr))
      //  arr2[0].a = 9
      //  console.log(arr);

      
    </script>
  </body>
</html>
