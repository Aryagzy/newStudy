<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 1.extends继承 关键字
      // 2.super关键字
      //   /*
      // super总结：
      //   1.继承必须要在constructor方法中去调用super
      //   2.原因是子类自己的this对象，必须通过父类的构造函数生成
      //   3.不调用super，子类就得不到this对象
      //   4.super只能在构造函数中
      //   5.super作为对象在普通方法中指向父类的原型对象
      //   6.调用super后，父类内部的this指向子类的实例
      //   7..super对属性赋值，这时的super相当于this
      //   8.super作为对象在静态方法中，指向父类而不是原型对象
      //   9.子类的静态方法中通过super调用父类的方法时，方法内部的this指向了当前的子类，而不是子类的实例
      //  */
      // class Father {
      //   constructor(name,age) {
      //     this.name = 'father'
      //     this.age = 49
      //   }
      //   work() {
      //     console.log('I am working in ShangHai');
      //   }

      // }
      // class Children extends Father {
      //   constructor(name,age,play) {
      //     // super()
      //     this.name= name

      //   }

      // }
      // let Son = new Children('luky',3,'sing')
      // console.log(Son.name); //报错 不调用super，子类就得不到this对象

      // 3.super作为对象在普通方法中指向父类的原型对象！
      // class A {
      //   //类中属性的写法
      //   pa = 123
      //   p(){  //es6方法是挂载在原型上的
      //     return 3
      //   }
      // }
      // A.prototype.pa = 345
      // class B extends A {
      //   constructor() {
      //     super()
      //     console.log(super.p()); //3
      //     console.log(super.pa); //undefined 345
      //   }
      // }
      // let b = new B()

      // 4.调用super后，父类内部的this指向子类的实例
      // class A {
      //   constructor() {
      //     this.x = 1;
      //   }
      //   print() {
      //     console.log(this.x); //4
      //   }
      // }
      // class B extends A {
      //   constructor() {
      //     super();
      //     this.x = 4;
      //   }
      //   fn() {
      //     super.print();
      //     //相当于es5里面的super.print.call(this)
      //   }
      // }
      // let b = new B();
      // b.fn();

      // 5.super对属性赋值，这时的super相当于this
      // class A {
      //   constructor() {
      //     this.x = 1;
      //   }
      // }
      // class B extends A {
      //   constructor() {
      //     super();
      //     this.x = 4;
      //     super.x = 5 //this.x = 5
      //     console.log(super.x); //undefined
      //     console.log(this.x); //5
      //   }
      // }
      // let b = new B();

      // 6.super作为对象在静态方法中，指向父类而不是原型对象
      // class Parent {
      //   static myMethod(msg) { //静态方法，在类中
      //     console.log(`static-${msg}`);
      //   }
      //   myMethod(msg) { //普通方法，在原型上
      //     console.log(`普通${msg}`);
      //   }
      // }
      // class Children extends Parent {
      //   static myMethod(msg) {
      //     super.myMethod(msg) //指向父类
      //   }
      //   myMethod(msg) {
      //     super.myMethod(msg) //指向了父类中的原型对象
      //   }
      // }
      // Children.myMethod(1)//调用了静态方法
      // let children = new Children()
      // children.myMethod(2);//调用了普通方法

      // 7.子类的静态方法中通过super调用父类的方法时，方法内部的this指向了当前的子类，而不是子类的实例
      //   class A {
      //     constructor() {
      //       this.x = 1
      //     }
      //     static print() {
      //       console.log(this.x);
      //     }
      //   }
      //   class B extends A {
      //     constructor(){
      //       super()
      //       this.x = 2
      //     }
      //     static fn() {
      //       super.print()
      //     }
      //   }
      //  // B.x = 8
      //   B.fn()
    </script>
  </body>
</html>
